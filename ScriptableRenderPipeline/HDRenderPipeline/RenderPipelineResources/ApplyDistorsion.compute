#include "../../Core/ShaderLibrary/Common.hlsl"
#include "../Material/Builtin/BuiltinData.hlsl"

TEXTURE2D(_DepthTexture);
TEXTURE2D(_DistortionTexture);
TEXTURE2D(_DistortionDepthTexture);
TEXTURE2D(_GaussianPyramidColorTexture);
RW_TEXTURE2D(float4, _CameraColorTexture);

SamplerState sampler_GaussianPyramidColorTexture;

CBUFFER_START(cb)
    float4 _Size;
    float4 _GaussianPyramidColorMipSize;
CBUFFER_END

#pragma kernel KMain
[numthreads(8, 8, 1)]
void KMain(uint2 groupId : SV_GroupID, uint2 groupThreadId : SV_GroupThreadID, uint2 dispatchThreadId : SV_DispatchThreadID)
{
    // We use a bias when fetching distortion source pixels
    // This avoid artifacts when a distortion is overlapped by an opaque object
    const float _FetchBias = 0.9;

    // Get distortion values
    float4 encodedDistortion = LOAD_TEXTURE2D(_DistortionTexture, dispatchThreadId);
    float depthRaw = LOAD_TEXTURE2D(_DistortionDepthTexture, dispatchThreadId).r;

    float2 distortion;
    float2 distortionBlur;
    DecodeDistortion(encodedDistortion, distortion, distortionBlur);

    uint2 distortedEncodedDistortionId = dispatchThreadId + int2(distortion);

    float2 distordedDistortion;
    float2 distordedDistortionBlur;
    float4 encodedDistordedDistortion = LOAD_TEXTURE2D(_DistortionTexture, distortedEncodedDistortionId);
    float distordedDepthRaw = LOAD_TEXTURE2D(_DepthTexture, distortedEncodedDistortionId).r;
    DecodeDistortion(encodedDistordedDistortion, distordedDistortion, distordedDistortionBlur);

    if (distordedDepthRaw > depthRaw)
        return;

    // Get source pixel for distortion
    float2 distordedUV = float2(dispatchThreadId + int2(distortion * _FetchBias)) * _Size.zw;
    float mip = (_GaussianPyramidColorMipSize.z - 1) * clamp(distortionBlur.x, 0.0, 1.0);
    float4 sampled = SAMPLE_TEXTURE2D_LOD(_GaussianPyramidColorTexture, sampler_GaussianPyramidColorTexture, distordedUV, mip);

    _CameraColorTexture[dispatchThreadId] = sampled;
}
