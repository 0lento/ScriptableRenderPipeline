#pragma kernel TileLightListGen_NoDepthRT					LIGHTLISTGEN=TileLightListGen_NoDepthRT
#pragma kernel TileLightListGen_DepthRT						LIGHTLISTGEN=TileLightListGen_DepthRT			ENABLE_DEPTH_TEXTURE_BACKPLANE
#pragma kernel TileLightListGen_DepthRT_MSAA				LIGHTLISTGEN=TileLightListGen_DepthRT_MSAA		ENABLE_DEPTH_TEXTURE_BACKPLANE		MSAA_ENABLED
#pragma kernel TileLightListGen_NoDepthRT_SrcBigTile		LIGHTLISTGEN=TileLightListGen_NoDepthRT_SrcBigTile																	USE_TWO_PASS_TILED_LIGHTING
#pragma kernel TileLightListGen_DepthRT_SrcBigTile			LIGHTLISTGEN=TileLightListGen_DepthRT_SrcBigTile			ENABLE_DEPTH_TEXTURE_BACKPLANE							USE_TWO_PASS_TILED_LIGHTING
#pragma kernel TileLightListGen_DepthRT_MSAA_SrcBigTile		LIGHTLISTGEN=TileLightListGen_DepthRT_MSAA_SrcBigTile		ENABLE_DEPTH_TEXTURE_BACKPLANE		MSAA_ENABLED		USE_TWO_PASS_TILED_LIGHTING
#pragma kernel ClearAtomic

#include "CoreRP/ShaderLibrary/common.hlsl"
#include "ShaderBase.hlsl"
#include "LightLoop.cs.hlsl"
#include "LightingConvexHullUtils.hlsl"
#include "LightCullUtils.hlsl"

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
#include "SortingComputeUtils.hlsl"
#endif

#pragma only_renderers d3d11 ps4 xboxone vulkan metal

//#define EXACT_EDGE_TESTS
#define PERFORM_SPHERICAL_INTERSECTION_TESTS
#define CONV_HULL_TEST_ENABLED

CBUFFER_START(UnityLightListClustered)
int g_iNrVisibLights;

// XRTODO - DONE: Stereo-ize these
float4x4 g_mInvScrProjectionArr[2];
float4x4 g_mScrProjectionArr[2];

uint g_isOrthographic;
int _EnvLightIndexShift;
int _DecalIndexShift;

float g_fClustScale;
float g_fClustBase;
float g_fNearPlane;
float g_fFarPlane;
int	  g_iLog2NumClusters;		// numClusters = (1<<g_iLog2NumClusters)

float4 g_screenSize;
int g_iNumSamplesMSAA;

CBUFFER_END

// ClusteredUtils.hlsl is dependent on the constants declared in UnityLightListClustered :/
// g_fClustBase, g_fNearPlane, g_fFarPlane, g_iLog2NumClusters
#include "ClusteredUtils.hlsl"

// XRTODO: Reading from these textures and buffers must be stereo-ized
#ifdef MSAA_ENABLED
Texture2DMS<float> g_depth_tex : register( t0 );
#else
Texture2D g_depth_tex : register( t0 );
#endif
StructuredBuffer<float3> g_vBoundsBuffer : register( t1 );
StructuredBuffer<LightVolumeData> _LightVolumeData : register(t2);
StructuredBuffer<SFiniteLightBound> g_data : register( t3 );

#ifdef USE_TWO_PASS_TILED_LIGHTING
StructuredBuffer<uint> g_vBigTileLightList : register( t4 );		// don't support Buffer yet in unity
#endif


#define NR_THREADS			64

// XRTODO: Stereo-ize writes to these buffers (except g_LayeredSingleIdxBuffer)
// output buffer
RWStructuredBuffer<uint> g_vLayeredLightList : register( u0 );			// don't support RWBuffer yet in unity
RWStructuredBuffer<uint> g_LayeredOffset : register( u1 );				// don't support RWBuffer yet in unity
RWStructuredBuffer<uint> g_LayeredSingleIdxBuffer : register( u2 );		// don't support RWBuffer yet in unity

// XRTODO: Stereo-ize writes to g_logBaseBuffer
#ifdef ENABLE_DEPTH_TEXTURE_BACKPLANE
RWStructuredBuffer<float> g_logBaseBuffer : register( u3 );				// don't support RWBuffer yet in unity
#endif


#define MAX_NR_COARSE_ENTRIES		128

groupshared unsigned int coarseList[MAX_NR_COARSE_ENTRIES];
groupshared unsigned int clusterIdxs[MAX_NR_COARSE_ENTRIES/2];
groupshared float4 lightPlanes[4*6]; // Each plane is defined by a float4. 6 planes per light, 4 lights (24 planes)

groupshared uint lightOffs;

#ifdef ENABLE_DEPTH_TEXTURE_BACKPLANE
groupshared uint ldsZMax;
#endif

#ifdef EXACT_EDGE_TESTS
groupshared uint ldsIsLightInvisible;
groupshared uint lightOffs2;
#endif

#ifdef PERFORM_SPHERICAL_INTERSECTION_TESTS
groupshared uint lightOffsSph;
#endif

// XRTODO - DONE: Stereo-ize access to g_mInvScrProjection, pass in eyeIndex
float GetLinearDepth(float zDptBufSpace, uint eyeIndex)    // 0 is near 1 is far
{
    float4x4 g_mInvScrProjection = g_mInvScrProjectionArr[eyeIndex];

    // for perspective projection m22 is zero and m23 is +1/-1 (depends on left/right hand proj)
	// however this function must also work for orthographic projection so we keep it like this.
    float m22 = g_mInvScrProjection[2].z, m23 = g_mInvScrProjection[2].w;
    float m32 = g_mInvScrProjection[3].z, m33 = g_mInvScrProjection[3].w;

    return (m22*zDptBufSpace+m23) / (m32*zDptBufSpace+m33);

    //float3 vP = float3(0.0f,0.0f,zDptBufSpace);
    //float4 v4Pres = mul(g_mInvScrProjection, float4(vP,1.0));
    //return v4Pres.z / v4Pres.w;
}

// XRTODO - DONE: Stereo-ize access to g_mScrProjection, pass in eyeIndex
float3 GetViewPosFromLinDepth(float2 v2ScrPos, float fLinDepth, uint eyeIndex)
{
    float4x4 g_mScrProjection = g_mScrProjectionArr[eyeIndex];

	bool isOrthographic = g_isOrthographic!=0;
	float fSx = g_mScrProjection[0].x;
	float fSy = g_mScrProjection[1].y;
	float fCx = isOrthographic ? g_mScrProjection[0].w : g_mScrProjection[0].z;
	float fCy = isOrthographic ? g_mScrProjection[1].w : g_mScrProjection[1].z;

#if USE_LEFT_HAND_CAMERA_SPACE
	bool useLeftHandVersion = true;
#else
	bool useLeftHandVersion = isOrthographic;
#endif

	float s = useLeftHandVersion ? 1 : (-1);
	float2 p = float2( (s*v2ScrPos.x-fCx)/fSx, (s*v2ScrPos.y-fCy)/fSy);

	return float3(isOrthographic ? p.xy : (fLinDepth*p.xy), fLinDepth);
}

// XRTODO - DONE: Stereo-ize access to g_mScrProjection, pass in eyeIndex
float GetOnePixDiagWorldDistAtDepthOne(uint eyeIndex)
{
    float4x4 g_mScrProjection = g_mScrProjectionArr[eyeIndex];
	float fSx = g_mScrProjection[0].x;
	float fSy = g_mScrProjection[1].y;

	return length( float2(1.0/fSx,1.0/fSy) );
}

// SphericalIntersectionTests and CullByExactEdgeTests are close to the versions
// in lightlistbuild-bigtile.compute.  But would need more re-factoring than needed
// right now.

// XRTODO - DONE: Stereo-ize these functions with eyeIndex
#ifdef EXACT_EDGE_TESTS
int CullByExactEdgeTests(uint threadID, int iNrCoarseLights, uint2 viTilLL, uint2 viTilUR, float fTileFarPlane, uint eyeIndex);
#endif
#ifdef PERFORM_SPHERICAL_INTERSECTION_TESTS
int SphericalIntersectionTests(uint threadID, int iNrCoarseLights, float2 screenCoordinate, uint eyeIndex);
#endif


// returns 1 for intersection and 0 for none

// XRTODO - DONE: Pass in eyeIndex
float4 FetchPlane(int l, int p, uint eyeIndex);

// XRTODO - DONE: Stereo-ize due to access to GetViewPosFromLinDepth
// We need eyeIndex
bool CheckIntersection(int l, int k, uint2 viTilLL, uint2 viTilUR, float suggestedBase, uint eyeIndex)
{
    // If this light's screen space depth bounds intersect this cluster...simple cluster test
    // TODO: Unify this code with the code in CheckIntersectionBasic...
	unsigned int val = (clusterIdxs[l>>1]>>(16*(l&1)))&0xffff;
	bool bIsHit = ((val>>0)&0xff)<=((uint) k) && ((uint) k)<=((val>>8)&0xff);
	if(bIsHit)
	{
#ifdef CONV_HULL_TEST_ENABLED
		float depthAtNearZ = ClusterIdxToZ(k, suggestedBase);
		float depthAtFarZ = ClusterIdxToZ(k+1, suggestedBase);

		for(int p=0; p<6; p++)
		{
			float4 plane = lightPlanes[6*(l&3)+p];

			bool bAllInvisib = true;

			for(int i=0; i<8; i++)
			{
				float x = (i&1)==0 ? viTilLL.x : viTilUR.x;
				float y = (i&2)==0 ? viTilLL.y : viTilUR.y;
				float z = (i&4)==0 ? depthAtNearZ : depthAtFarZ;
                // XRTODO - DONE: Stereo-ize this by passing in eyeIndex
                float3 vP = GetViewPosFromLinDepth( float2(x, y), z, eyeIndex);

                // Test each corner of the cluster against the light bounding box planes
				bAllInvisib = bAllInvisib && dot(plane, float4(vP,1.0))>0;
			}

			if(bAllInvisib) bIsHit = false;
		}
#endif
	}

	return bIsHit;
}

// l is the coarse light index, k is the cluster index
bool CheckIntersectionBasic(int l, int k)
{
	unsigned int val = (clusterIdxs[l>>1]>>(16*(l&1)))&0xffff;
	return ((val>>0)&0xff)<=((uint) k) && ((uint) k)<=((val>>8)&0xff);
}


[numthreads(NR_THREADS, 1, 1)]
void LIGHTLISTGEN(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)
{
    // XRTODO - DONE: Generate eyeIndex from u3GroupID.z
    uint eyeIndex = u3GroupID.z;

	uint2 tileIDX = u3GroupID.xy;
	uint t=threadID;

	const uint log2TileSize = firstbithigh(TILE_SIZE_CLUSTERED);
	uint nrTilesX = ((uint)g_screenSize.x +(TILE_SIZE_CLUSTERED-1))>>log2TileSize;
	uint nrTilesY = ((uint)g_screenSize.y +(TILE_SIZE_CLUSTERED-1))>>log2TileSize;

    // Screen space coordinates of clustered tile
	uint2 viTilLL = TILE_SIZE_CLUSTERED*tileIDX;
	uint2 viTilUR = min( viTilLL+uint2(TILE_SIZE_CLUSTERED,TILE_SIZE_CLUSTERED), uint2(g_screenSize.x, g_screenSize.y) );		// not width and height minus 1 since viTilUR represents the end of the tile corner.

	if(t==0)
	{
		lightOffs = 0;

#ifdef ENABLE_DEPTH_TEXTURE_BACKPLANE
		ldsZMax = 0;
#endif
	}

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
	GroupMemoryBarrierWithGroupSync();
#endif

	float dpt_ma=1.0;

#ifdef ENABLE_DEPTH_TEXTURE_BACKPLANE
	// establish min and max depth first
	dpt_ma=0.0;

	for(int idx=t; idx<(TILE_SIZE_CLUSTERED*TILE_SIZE_CLUSTERED); idx+=NR_THREADS)
	{
        // XRTODO: We need to stereo-ize access to g_depth_tex.  This is the only time we use viTilLL
        // to generate a screen-space texture coordinate, so we can localize our stereo texture access here.
        // For double-wide, we need to sample the correct half.  
        // For instancing/multi-view, the right texture layer. When we add support for that, we need to pass in 
        // an extra uint2 for layer index.
		uint2 uPixCrd = min( uint2(viTilLL.x+(idx&(TILE_SIZE_CLUSTERED-1)), viTilLL.y+(idx>>log2TileSize)), uint2(g_screenSize.x-1, g_screenSize.y-1) );
#ifdef MSAA_ENABLED
		for(int i=0; i<g_iNumSamplesMSAA; i++)
		{
		const float fDpth = FetchDepthMSAA(g_depth_tex, uPixCrd, i);
#else
		const float fDpth = FetchDepth(g_depth_tex, uPixCrd);
#endif
		if(fDpth<VIEWPORT_SCALE_Z)		// if not skydome
		{
			dpt_ma = max(fDpth, dpt_ma);
		}
#ifdef MSAA_ENABLED
		}
#endif
	}

    // Max across TG
    // Why is this a uint? Can't we save floats in shared mem?
	InterlockedMax(ldsZMax, asuint(dpt_ma) );


#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
	GroupMemoryBarrierWithGroupSync();
#endif
	dpt_ma = asfloat(ldsZMax);
	if(dpt_ma<=0.0) dpt_ma = VIEWPORT_SCALE_Z;		// assume sky pixel
#endif

    // 'Normalized' coordinates of tile, for use with AABB bounds in g_vBoundsBuffer
	float2 vTileLL = float2(viTilLL.x/g_screenSize.x, viTilLL.y/g_screenSize.y);
	float2 vTileUR = float2(viTilUR.x/g_screenSize.x, viTilUR.y/g_screenSize.y);

	// build coarse list using AABB
#ifdef USE_TWO_PASS_TILED_LIGHTING
	const uint log2BigTileToClustTileRatio = firstbithigh(64) - log2TileSize;

    // XRTODO - DONE: Properly stereo-ize access to g_vBigTileLightList
    // All of this code is localized here, so I don't really have to worry about side-effects further on down
    // I need to generate NrBigTilesY, so I can generate a per-eye offset/base into g_vBigTileLightList
    // Since bigTileIdx is used twice (once for count, once for the light list), I should probably fix that one.
    // Would be worth function-alizing, because this code is shared with FPTL/lightlistbuild.compute
    int NrBigTilesX = (nrTilesX + ((1<<log2BigTileToClustTileRatio)-1)) >> log2BigTileToClustTileRatio;
    int NrBigTilesY = (nrTilesY + ((1<<log2BigTileToClustTileRatio)-1)) >> log2BigTileToClustTileRatio;
    const int bigTileBase = eyeIndex * NrBigTilesX * NrBigTilesY;
	const int bigTileIdx = bigTileBase + ((tileIDX.y>>log2BigTileToClustTileRatio)*NrBigTilesX) + (tileIDX.x>>log2BigTileToClustTileRatio);		// map the idx to 64x64 tiles
	
    int nrBigTileLights = g_vBigTileLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*bigTileIdx+0];
	for(int l0=(int) t; l0<(int) nrBigTileLights; l0 += NR_THREADS)
	{
		int l = g_vBigTileLightList[MAX_NR_BIG_TILE_LIGHTS_PLUS_ONE*bigTileIdx+l0+1];
#else
	for(int l=(int) t; l<(int) g_iNrVisibLights; l += NR_THREADS)
	{
#endif
        // XRTODO - DONE: Once we have our light index (l), we need to make sure it indexes the 
        // correct portion of g_vBoundsBuffer. I have that code in GenerateScreenSpaceBoundsIndices

        // TODO: Seems kinda funny that we repeat this exact code here, bigtile, and FPTL...

        const ScreenSpaceBoundsIndices boundsIndices = GenerateScreenSpaceBoundsIndices(l, g_iNrVisibLights, eyeIndex);
        const float2 vMi = g_vBoundsBuffer[boundsIndices.min].xy;
        const float2 vMa = g_vBoundsBuffer[boundsIndices.max].xy;

		if( all(vMa>vTileLL) && all(vMi<vTileUR))
		{
			unsigned int uInc = 1;
			unsigned int uIndex;
			InterlockedAdd(lightOffs, uInc, uIndex);
			if(uIndex<MAX_NR_COARSE_ENTRIES) coarseList[uIndex] = l;		// add to light list
		}
	}

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
	GroupMemoryBarrierWithGroupSync();
#endif

	int iNrCoarseLights = min(lightOffs,MAX_NR_COARSE_ENTRIES);

    // XRTODO - DONE: Stereo-ize by passing in eyeIndex
#ifdef PERFORM_SPHERICAL_INTERSECTION_TESTS
	iNrCoarseLights = SphericalIntersectionTests( t, iNrCoarseLights, float2(min(viTilLL.xy+uint2(TILE_SIZE_CLUSTERED/2,TILE_SIZE_CLUSTERED/2), uint2(g_screenSize.x-1, g_screenSize.y-1))), eyeIndex );
#endif

#ifdef ENABLE_DEPTH_TEXTURE_BACKPLANE

    // XRTODO - DONE: Stereo-ize access to GetLinearDepth with eyeIndex
#if USE_LEFT_HAND_CAMERA_SPACE
    float fTileFarPlane = GetLinearDepth(dpt_ma, eyeIndex);
#else // USE_LEFT_HAND_CAMERA_SPACE
    float fTileFarPlane = -GetLinearDepth(dpt_ma, eyeIndex);
#endif
	float suggestedBase = SuggestLogBase50(fTileFarPlane);
#else // ENABLE_DEPTH_TEXTURE_BACKPLANE
	float fTileFarPlane = g_fFarPlane;
	float suggestedBase = g_fClustBase;
#endif


    // XRTODO - DONE: Stereo-ize by passing in eyeIndex
#ifdef EXACT_EDGE_TESTS
    iNrCoarseLights = CullByExactEdgeTests(t, iNrCoarseLights, viTilLL.xy, viTilUR.xy, fTileFarPlane, eyeIndex);
#endif

	// sort lights (gives a more efficient execution in both deferred and tiled forward lighting).
    // TODO: Why not sort on console?
#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
	SORTLIST(coarseList, iNrCoarseLights, MAX_NR_COARSE_ENTRIES, t, NR_THREADS);
#endif

	//////////// cell specific code
	{
        // This code is a little tricky. For each light in our coarse list (and the list is associated with the screen tile),
        // we find a cluster associated with the lights AABB Z value.  For each light, we have a min and max cluster index.
        // And because the cluster index is a max of 255, we are able to encode 4 cluster indices per 32-bit DWORD.
        // Therefore, we can encode 2 lights per uint (light 0 min idx, light 0 max idx, light 1...)
        // Each iteration of the loop goes over two neighboring lights in the coarseList, unfortunate name choice of 'l'

        // TODO: We should write some encode/decode functions to help put cluster indices into the shared mem buffer,
        // and extract them later.  The code that reads from clusterIdx is hairy.

		for(int l=(int) t; l<((iNrCoarseLights+1)>>1); l += NR_THREADS)
		{
            // XRTODO - DONE: Stereo-ize access to g_vBoundsBuffer, run l0 and l1 through GenerateScreenSpaceBoundsIndices
            // The logic here is a bit confusing.  We seem to process pairs of lights, and 
            // It's for the cluster in the tile (the depth layer slice whatever)
			const int l0 = coarseList[2*l+0], l1 = coarseList[min(2*l+1,iNrCoarseLights-1)];
            const ScreenSpaceBoundsIndices l0Bounds = GenerateScreenSpaceBoundsIndices(l0, g_iNrVisibLights, eyeIndex);
            const ScreenSpaceBoundsIndices l1Bounds = GenerateScreenSpaceBoundsIndices(l1, g_iNrVisibLights, eyeIndex);

            // XRTODO - DONE: Stereo-ize GetLinearDepth with eyeIndex
            const unsigned int clustIdxMi0 = (const unsigned int)min(255, SnapToClusterIdx(GetLinearDepth(g_vBoundsBuffer[l0Bounds.min].z, eyeIndex), suggestedBase));
            const unsigned int clustIdxMa0 = (const unsigned int)min(255, SnapToClusterIdx(GetLinearDepth(g_vBoundsBuffer[l0Bounds.max].z, eyeIndex), suggestedBase));
            const unsigned int clustIdxMi1 = (const unsigned int)min(255, SnapToClusterIdx(GetLinearDepth(g_vBoundsBuffer[l1Bounds.min].z, eyeIndex), suggestedBase));
            const unsigned int clustIdxMa1 = (const unsigned int)min(255, SnapToClusterIdx(GetLinearDepth(g_vBoundsBuffer[l1Bounds.max].z, eyeIndex), suggestedBase));
			clusterIdxs[l] = (clustIdxMa1<<24) | (clustIdxMi1<<16) | (clustIdxMa0<<8) | (clustIdxMi0<<0);
		}
	}

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
	GroupMemoryBarrierWithGroupSync();
#endif

	int nrClusters = (1<<g_iLog2NumClusters);



	//////////////////////////////////////////////////////////

	uint start = 0;
	int i=(int) t;
	int iSpaceAvail = 0;
	int iSum = 0;
    // Each thread in the TG represents a cluster index, and tests all coarse lights against that cluster.
    // It should be noted that nrClusters can never be greater than the TG size, otherwise, this code doesn't work!
	if(i<nrClusters)
	{
        // Each thread checks it's respective cluster against all coarse lights for intersection.
        // At the end, 'iSum' represents the number of lights that intersect this cluster!
		for(int l=0; l<iNrCoarseLights; l++)
		{
			iSum += (CheckIntersectionBasic(l, i) ? 1 : 0);
		}

        // We have a limit to the number of lights we will track in a cluster (128). This is how much memory we
        // want to allocate out of g_LayeredSingleIdxBuffer.
		iSpaceAvail = min(iSum,MAX_NR_COARSE_ENTRIES);							// combined storage for both direct lights and reflection
		InterlockedAdd(g_LayeredSingleIdxBuffer[0], (uint) iSpaceAvail, start);		// alloc list memory

        // All the light lists live in g_vLayeredLightList.  They aren't sorted in any manner, and it's tightly packed.
        // The allocation can handle the max lights per tile, but it likely won't use all the memory.
        // g_LayeredSingleIdxBuffer is recording the allocations out of the buffer.  
        // 'start' indicates the offset into g_vLayeredLightList for the _cluster_ being 
        // processed by this thread. And the TG is processing the tile. 
        // 'iSpaceAvail' is how many total lights are in this cluster.
        // This allocation might be roughly over, because CheckIntersectionBasic is a very basic check.

        // XRTODO: For stereo, we don't have to adjust anything into g_LayeredSingleIdxBuffer. Each thread is processing it's own
        // cluster, so we just need to make sure there is enough memory allocated in g_vLayeredLightList for two eyes worth of
        // lists.  The offset we get from start is good enough.  We do have to store the offset into the 
        // stereo-corrected half of g_LayeredOffset.
	}

	// All our cull data are in the same list, but at render time envLights are separated so we need to shift the index
	// to make it work correctly
	int shiftIndex[LIGHTCATEGORY_COUNT];
	ZERO_INITIALIZE_ARRAY(int, shiftIndex, LIGHTCATEGORY_COUNT);
    // TODO: Why is this indexed like this?
	shiftIndex[LIGHTCATEGORY_COUNT - 2] = _EnvLightIndexShift;
	shiftIndex[LIGHTCATEGORY_COUNT - 1] = _DecalIndexShift;

	int categoryListCount[LIGHTCATEGORY_COUNT]; // direct light count and reflection lights
	ZERO_INITIALIZE_ARRAY(int, categoryListCount, LIGHTCATEGORY_COUNT);

	uint offs = start;
	for(int ll=0; ll<iNrCoarseLights; ll+=4)
	{
        // Process in chunks of 4 lights from the coarse tile list

		int p = i>>2;
		int m = i&3;
        // XRTODO - DONE: Pass in eyeIndex to FetchPlane, as it looks into g_data (SFiniteLightBound)
		if(i<24) lightPlanes[6*m+p] = FetchPlane(min(iNrCoarseLights-1,ll+m), p, eyeIndex);

        // The first 24 threads in the TG each generate 1 plane equation.  There are
        // 6 planes per light, and we process 4 lights at a time, hence, 24 threads.
        // We could do more, but this might be all the LDS that can be spared...

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
		GroupMemoryBarrierWithGroupSync();
#endif

		for(int l=ll; l<min(iNrCoarseLights,(ll+4)); l++)
		{
            // XRTODO - DONE: Stereo-ize CheckIntersection by passing in eyeIndex to GetViewPosFromLinDepth
			if(offs<(start+iSpaceAvail) && i<nrClusters && CheckIntersection(l, i, viTilLL.xy, viTilUR.xy, suggestedBase, eyeIndex) )
			{
                // XRTODO - DONE: Stereo-ize index into _LightVolumeData, run coarseList[l] thru GenerateLightCullDataIndex
                const int lightVolIndex = GenerateLightCullDataIndex(coarseList[l], g_iNrVisibLights, eyeIndex);
                uint lightCategory = _LightVolumeData[lightVolIndex].lightCategory;
				++categoryListCount[lightCategory];
				g_vLayeredLightList[offs++] = coarseList[l] - shiftIndex[lightCategory];			// reflection lights will be last since we sorted
			    
                // TODO: I think there _might_ be a potential bug here. The way this code seems to work is that
                // as each light comes in, they are added to the allocated list in g_vLayeredLightList.
                // As each light is added, the respective category count is incremented, and the raw light index is
                // altered by subtracting the shift associated with the category.  So these light indices are category
                // dependent. Since they are category dependent, these indices have to grouped into category sub-lists
                // inside the cluster's allocation.  But...when the coarseList is generated, there's no guarantee it is sorted
                // unless it runs through the SORTLIST routine above.
            }
		}

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
		GroupMemoryBarrierWithGroupSync();
#endif
	}

    // We now fill information about each light type into g_LayeredOffset
    // The offset into g_vLayeredLightList, encoded with the number of lights in the category
    // The encoded offsets are assuming the lights are sorted by category in the cluster list
	uint localOffs=0;

    // XRTODO: Stereo-ize this initial 'offs' to jump into the correct half of g_LayeredOffs.
    // The offsets are organized Category/Cluster/Row/Column.
    // For stereo, we just add eyeIndex*LIGHTCATEGORY_COUNT*nrClusters*nrTilesX*nrTilesY
	offs = i*nrTilesX*nrTilesY + tileIDX.y*nrTilesX + tileIDX.x;
	for(int category=0; category<LIGHTCATEGORY_COUNT; category++)
	{
		int numLights = min(categoryListCount[category],31);		// only allow 5 bits
		if(i<nrClusters)
		{
			g_LayeredOffset[offs] = (start+localOffs) | (((uint) numLights)<<27);
			offs += (nrClusters*nrTilesX*nrTilesY);
			localOffs += categoryListCount[category];		// use unclamped count for localOffs
		}
	}

#ifdef ENABLE_DEPTH_TEXTURE_BACKPLANE
    // XRTODO: Stereo-ize this, as this is per-eye set of tiles
    // Add eyeIndex*nrTilesY*nrTilesX to this index
	if(threadID==0) g_logBaseBuffer[tileIDX.y*nrTilesX + tileIDX.x] = suggestedBase;
#endif
}


// XRTODO - DONE: Must be stereo-ized because it fetches from g_data
// Pass in eyeIndex
float4 FetchPlane(int l, int p, uint eyeIndex)
{
    // XRTODO - DONE: Use eyeIndex and coarseList[l] to index into g_data
    // use GenerateLightCullDataIndex
    const int lightBoundIndex = GenerateLightCullDataIndex(coarseList[l], g_iNrVisibLights, eyeIndex);
    SFiniteLightBound lgtDat = g_data[lightBoundIndex];

	const float3 boxX = lgtDat.boxAxisX.xyz;
	const float3 boxY = lgtDat.boxAxisY.xyz;
	const float3 boxZ = -lgtDat.boxAxisZ.xyz;           // flip axis (so it points away from the light direction for a spot-light)
	const float3 center = lgtDat.center.xyz;
	const float radius = lgtDat.radius;
	const float2 scaleXY = lgtDat.scaleXY;

	return GetHullPlaneEq(boxX, boxY, boxZ, center, scaleXY, p);
}




// XRTODO - DONE: Stereo-ize for a bunch of use cases! Pass in eyeIndex!
// Needed for GetViewPosFromLinDepth, GetOnePixDiagWorldDistAtDepthOne, and g_data
#ifdef PERFORM_SPHERICAL_INTERSECTION_TESTS
int SphericalIntersectionTests(uint threadID, int iNrCoarseLights, float2 screenCoordinate, uint eyeIndex)
{
    // XRTODO - DONE: Stereo-ize access with eyeIndex
#if USE_LEFT_HAND_CAMERA_SPACE
    float3 V = GetViewPosFromLinDepth( screenCoordinate, 1.0, eyeIndex);
#else
	float3 V = GetViewPosFromLinDepth( screenCoordinate, -1.0, eyeIndex);
#endif

    // XRTODO - DONE: Stereo-ize access with eyeIndex
    float onePixDiagDist = GetOnePixDiagWorldDistAtDepthOne(eyeIndex);
	float halfTileSizeAtZDistOne = (TILE_SIZE_CLUSTERED/2)*onePixDiagDist;		// scale by half a tile

	for(int l=threadID; l<iNrCoarseLights; l+=NR_THREADS)
	{
        // XRTODO - DONE: Stereo-ize access with eyeIndex and GenerateLightCullDataIndex
        // Use it on coarseList[l], use result to index g_data
        const int lightBoundIndex = GenerateLightCullDataIndex(coarseList[l], g_iNrVisibLights, eyeIndex);
        SFiniteLightBound lgtDat = g_data[lightBoundIndex];

		if( !DoesSphereOverlapTile(V, halfTileSizeAtZDistOne, lgtDat.center.xyz, lgtDat.radius, g_isOrthographic!=0) )
			coarseList[l]=UINT_MAX;
	}

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
		GroupMemoryBarrierWithGroupSync();
#endif

	// to greedy to double buffer coarseList lds on this so serializing removal of gaps.
	if(threadID==0)
	{
		int offs = 0;
		for(int l=0; l<iNrCoarseLights; l++)
		{
			if(coarseList[l]!=UINT_MAX)
				coarseList[offs++] = coarseList[l];
		}
		lightOffsSph = offs;
	}

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
	GroupMemoryBarrierWithGroupSync();
#endif

	return lightOffsSph;
}
#endif







#ifdef EXACT_EDGE_TESTS

// XRTODO - DONE: Stereo-ize for access to GetViewPosFromLinDepth, use eyeIndex
float3 GetTileVertex(uint2 viTilLL, uint2 viTilUR, int i, float fTileFarPlane, uint eyeIndex)
{
	float x = (i&1)==0 ? viTilLL.x : viTilUR.x;
	float y = (i&2)==0 ? viTilLL.y : viTilUR.y;
	float z = (i&4)==0 ? g_fNearPlane : fTileFarPlane;
#if !USE_LEFT_HAND_CAMERA_SPACE
	z = -z;
#endif
    // XRTODO - DONE: Pass in eyeIndex
    return GetViewPosFromLinDepth( float2(x, y), z, eyeIndex);
}

// XRTODO - DONE: Stereo-ize for access to GetTileVertex, use eyeIndex
void GetFrustEdge(out float3 vP0, out float3 vE0, const int e0, uint2 viTilLL, uint2 viTilUR, float fTileFarPlane, uint eyeIndex)
{
	int iSection = e0>>2;		// section 0 is side edges, section 1 is near edges and section 2 is far edges
	int iSwizzle = e0&0x3;

	int i=iSwizzle + (2*(iSection&0x2));	// offset by 4 at section 2
    // XRTODO - DONE: Pass in eyeIndex
    vP0 = GetTileVertex(uint2(viTilLL.x, viTilUR.y), uint2(viTilUR.x, viTilLL.y), i, fTileFarPlane, eyeIndex);

#if USE_LEFT_HAND_CAMERA_SPACE
	float3 edgeSectionZero = g_isOrthographic==0 ? vP0 : float3(0.0,0.0,1.0);
#else
	float3 edgeSectionZero = g_isOrthographic==0 ? vP0 : float3(0.0,0.0,-1.0);
#endif

	vE0 = iSection == 0 ? edgeSectionZero : (((iSwizzle & 0x2) == 0 ? 1.0f : (-1.0f)) * ((int)(iSwizzle & 0x1) == (iSwizzle >> 1) ? float3(1, 0, 0) : float3(0, 1, 0)));
}

// XRTODO - DONE: Stereo-ize with eyeIndex, used for indexing _LightVolumeData and g_data, 
// and with GetFrustEdge and GetTileVertex functions
int CullByExactEdgeTests(uint threadID, int iNrCoarseLights, uint2 viTilLL, uint2 viTilUR, float fTileFarPlane, uint eyeIndex)
{
	if(threadID==0) lightOffs2 = 0;

	const bool bOnlyNeedFrustumSideEdges = true;
	const int nrFrustEdges = bOnlyNeedFrustumSideEdges ? 4 : 8;	// max 8 since we never need to test 4 far edges of frustum since they are identical vectors to near edges and plane is placed at vP0 on light hull.

	const int totNrEdgePairs = 12*nrFrustEdges;
	for(int l=0; l<iNrCoarseLights; l++)
	{
		if(threadID==0) ldsIsLightInvisible=0;

#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
		GroupMemoryBarrierWithGroupSync();
#endif
        // XRTODO - DONE: stereo-ize index used to access _LightVolumeData (and g_data), use GenerateLightCullDataIndex and eyeIndex
        const int lightCullIndex = GenerateLightCullDataIndex(coarseList[l], g_iNrVisibLights, eyeIndex);
		UNITY_BRANCH if (_LightVolumeData[lightCullIndex].lightVolume != LIGHTVOLUMETYPE_SPHERE)		// don't bother doing edge tests for sphere lights since these have camera aligned bboxes.
		{
            // XRTODO - DONE: stereo-ize index used to access g_data, use the same index generated above from idxCoarse
            SFiniteLightBound lgtDat = g_data[lightCullIndex];

			const float3 boxX = lgtDat.boxAxisX.xyz;
			const float3 boxY = lgtDat.boxAxisY.xyz;
			const float3 boxZ = -lgtDat.boxAxisZ.xyz;           // flip axis (so it points away from the light direction for a spot-light)
			const float3 center = lgtDat.center.xyz;
			const float2 scaleXY = lgtDat.scaleXY;

			for(int i=threadID; i<totNrEdgePairs; i+=NR_THREADS)
			{
				int e0 = (int) (((uint)i)/((uint) nrFrustEdges)); // should become a shift right
				int e1 = i - e0*nrFrustEdges;

				int idx_cur=0, idx_twin=0;
				float3 vP0, vE0;
				GetHullEdge(idx_cur, idx_twin, vP0, vE0, e0, boxX, boxY, boxZ, center, scaleXY);


				float3 vP1, vE1;
                // XRTODO - DONE: Stereo-ize to use GetFrustEdge, use eyeIndex
                GetFrustEdge(vP1, vE1, e1, viTilLL, viTilUR, fTileFarPlane, eyeIndex);

				// potential separation plane
				float3 vN = cross(vE0, vE1);

				int positive=0, negative=0;
				for(int k=1; k<8; k++)		// only need to test 7 verts (technically just 6).
				{
					int j = (idx_cur+k)&0x7;
					float3 vPh = GetHullVertex(boxX, boxY, boxZ, center, scaleXY, j);
					float fSignDist = idx_twin==j ? 0.0 : dot(vN, vPh-vP0);
					if(fSignDist>0) ++positive; else if(fSignDist<0) ++negative;
				}
				int resh = (positive>0 && negative>0) ? 0 : (positive>0 ? 1 : (negative>0 ? (-1) : 0));

				positive=0; negative=0;
				for(int j=0; j<8; j++)
				{
                    // XRTODO - DONE: Stereo-ize to use GetTileVertex, use eyeIndex
                    float3 vPf = GetTileVertex(viTilLL, viTilUR, j, fTileFarPlane, eyeIndex);
					float fSignDist = dot(vN, vPf-vP0);
					if(fSignDist>0) ++positive; else if(fSignDist<0) ++negative;
				}
				int resf = (positive>0 && negative>0) ? 0 : (positive>0 ? 1 : (negative>0 ? (-1) : 0));

				bool bFoundSepPlane = (resh*resf)<0;

				if(bFoundSepPlane) InterlockedOr(ldsIsLightInvisible, 1);
			}
		}
#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
		GroupMemoryBarrierWithGroupSync();
#endif
		if(threadID==0 && ldsIsLightInvisible==0)
		{
			coarseList[lightOffs2++] = coarseList[l];
		}
	}
#if !defined(SHADER_API_XBOXONE) && !defined(SHADER_API_PSSL)
		GroupMemoryBarrierWithGroupSync();
#endif
	return lightOffs2;
}
#endif



[numthreads(1, 1, 1)]
void ClearAtomic(uint threadID : SV_GroupIndex, uint3 u3GroupID : SV_GroupID)
{
	g_LayeredSingleIdxBuffer[0]=0;
}
