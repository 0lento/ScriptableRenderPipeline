//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

#define PRESET_ULTRA 0

#if PRESET_ULTRA
    // E.g. for 1080p: (1920/4)x(1080/4)x(256) = 33,177,600 voxels
    #define VBUFFER_TILE_SIZE   4
    #define VBUFFER_SLICE_COUNT 256
#else
    // E.g. for 1080p: (1920/8)x(1080/8)x(128) =  4,147,200 voxels
    #define VBUFFER_TILE_SIZE   8
    #define VBUFFER_SLICE_COUNT 128
#endif

#pragma kernel VolumetricLightingAllLights VolumetricLighting=VolumetricLightingAllLights LIGHTLOOP_SINGLE_PASS
#pragma kernel VolumetricLightingClustered VolumetricLighting=VolumetricLightingClustered LIGHTLOOP_TILE_PASS   USE_CLUSTERED_LIGHTLIST

#pragma enable_d3d11_debug_symbols

#include "../../../ShaderPass/ShaderPass.cs.hlsl"
#define SHADERPASS    SHADERPASS_VOLUMETRIC_LIGHTING
#define GROUP_SIZE_1D 16
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "../../../../Core/ShaderLibrary/Common.hlsl"
#include "../../../../Core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "../../../../Core/ShaderLibrary/VolumeRendering.hlsl"

#include "../VolumetricLighting.cs.hlsl"
#define UNITY_MATERIAL_LIT // Need to be defined before including Material.hlsl
#include "../../../ShaderVariables.hlsl"
#include "../../../Lighting/Lighting.hlsl" // This includes Material.hlsl

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

RW_TEXTURE3D(float4, _VBufferLighting); // RGB = radiance, A = optical depth
TEXTURE3D(_VBufferLightingPrev);        // RGB = radiance, A = optical depth

CBUFFER_START(UnityVolumetricLighting)
    float4x4 _VBufferCoordToViewDirWS; // Actually just 3x3, but Unity can only set 4x4
CBUFFER_END

//--------------------------------------------------------------------------------------------------
// Implementation
//--------------------------------------------------------------------------------------------------

struct Ray
{
    float3 originWS;
    float3 directionWS; // Normalized
    float  ratioLenToZ; // 1 / ViewSpaceZ
    float  ratioZtoLen; // ViewSpaceZ
};

// Computes the in-scattered radiance along the ray.
void FillVolumetricLightingBuffer(Ray cameraRay, uint2 voxelCoord, uint2 tileCoord)
{
    LightLoopContext context;
    // ZERO_INITIALIZE(LightLoopContext, context);
    context.shadowContext = InitShadowContext();

    uint   featureFlags = 0xFFFFFFFF;      // TODO
    float4 depthParams  = _VBufferDepthEncodingParams;

    float z0 = depthParams.x;              // View space Z coordinate of the near plane
    float t0 = z0 * cameraRay.ratioLenToZ; // Distance to the near plane
    float de = rcp(VBUFFER_SLICE_COUNT);   // Log-encoded distance between slices

    float3 totalRadiance = 0;
    float  opticalDepth  = 0;

    uint sliceCountHack = max(VBUFFER_SLICE_COUNT, (uint)z0); // Prevent unrolling...

    // TODO: replace 'sliceCountHack' with VBUFFER_SLICE_COUNT when the shader compiler bug is fixed.
    for (uint s = 0; s < sliceCountHack; s++)
    {
        float e1 = s * de + de; // (s + 1) / sliceCount
        float z1 = DecodeLogarithmicDepth(e1, depthParams);
        float t1 = z1 * cameraRay.ratioLenToZ;
        float dt = t1 - t0;

        // TODO: low-discrepancy point set.
        float t = t0 + 0.5 * dt;
        float z = t * cameraRay.ratioZtoLen;
        float3 positionWS = cameraRay.originWS + t * cameraRay.directionWS;

        // Get volume properties at 't'.
        float3 scattering = _GlobalFog_Scattering;
        float  extinction = _GlobalFog_Extinction;

        float3 sampleRadiance = 0;

        if (featureFlags & LIGHTFEATUREFLAGS_DIRECTIONAL)
        {
            for (uint i = 0; i < _DirectionalLightCount; ++i)
            {
                // Fetch the light.
                DirectionalLightData lightData = _DirectionalLightDatas[i];

                float3 L         = -lightData.forward; // Lights point backwards in Unity
                float  intensity = 1;
                float3 color     = lightData.color;

                [branch] if (lightData.shadowIndex >= 0)
                {
                    float shadow = GetDirectionalShadowAttenuation(context.shadowContext, positionWS,
                                   float3(0, 0, 0), lightData.shadowIndex, L);

                    intensity *= shadow;
                }

                // Note: no global fog attenuation along shadow rays for directional lights.

                [branch] if (lightData.cookieIndex >= 0)
                {
                    float3 lightToSample = positionWS - lightData.positionWS;
                    float4 cookie = EvaluateCookie_Directional(context, lightData, lightToSample);

                    color     *= cookie.rgb;
                    intensity *= cookie.a;
                }

                // Compute the amount of in-scattered radiance.
                sampleRadiance += color * intensity;
            }
        }

        if (featureFlags & LIGHTFEATUREFLAGS_PUNCTUAL)
        {
            uint punctualLightCount;

        #ifdef LIGHTLOOP_TILE_PASS
            PositionInputs posInput;
            posInput.depthVS = z;
            posInput.unTileCoord = tileCoord;

            // TODO: do not refetch between consecutive samples if possible.
            uint punctualLightStart;
            GetCountAndStartCluster(posInput, LIGHTCATEGORY_PUNCTUAL, punctualLightStart, punctualLightCount);
        #else
            punctualLightCount = _PunctualLightCount;
        #endif

            for (uint i = 0; i < punctualLightCount; ++i)
            {
            #ifdef LIGHTLOOP_TILE_PASS
                uint punctualLightIndex = FetchIndex(punctualLightStart, i);
            #else
                uint punctualLightIndex = i;
            #endif

                // Fetch the light.
                LightData lightData  = _LightDatas[punctualLightIndex];
                int       lightType  = lightData.lightType;

                float3 lightToSample = positionWS - lightData.positionWS;
                float  distSq        = dot(lightToSample, lightToSample);
                float  dist          = sqrt(distSq);
                float3 L             = lightToSample * -rsqrt(distSq);
                float  clampedDistSq = max(distSq, 0.5 * dt); // Hack to reduce undersampling
                float  intensity     = GetPunctualShapeAttenuation(lightData, L, clampedDistSq);
                float3 color         = lightData.color;

                intensity *= Transmittance(OpticalDepthHomogeneous(extinction, dist));

                [branch] if (lightData.shadowIndex >= 0)
                {
                    // TODO: make projector lights cast shadows.
                    float shadow = GetPunctualShadowAttenuation(context.shadowContext, positionWS,
                                   float3(0, 0, 0), lightData.shadowIndex, float4(L, dist));

                    intensity *= lerp(1, shadow, lightData.shadowDimmer);
                }

                // Projector lights always have a cookies, so we can perform clipping inside the if().
                [branch] if (lightData.cookieIndex >= 0)
                {
                    float4 cookie = EvaluateCookie_Punctual(context, lightData, lightToSample);

                    color     *= cookie.rgb;
                    intensity *= cookie.a;
                }

                // Compute the amount of in-scattered radiance.
                sampleRadiance += color * intensity;
            }
        }

        // We consider the volume to be homogeneous along the interval (within the voxel).
        // Integral{a, b}{Transmittance(0, x) dx} = Transmittance(0, a) * Integral{0, b - a}{Transmittance(a, a + x) dx}.
        float transmittance = Transmittance(opticalDepth) * TransmittanceIntegralHomogeneous(extinction, dt);

        // Compute the optical depth up to the sample.
        opticalDepth  += extinction * (t - t0);

        // We consider the lighting (and the volume properties) to be constant along the interval (within the voxel).
        totalRadiance += (transmittance * IsotropicPhaseFunction()) * scattering * sampleRadiance;

        // Store the voxel data. TODO: reprojection using camera motion vectors.
        _VBufferLighting[uint3(voxelCoord, s)] = float4(totalRadiance, opticalDepth);

        // Compute the optical depth up to the end of the interval.
        opticalDepth += extinction * (t1 - t);

        t0 = t1;
    }
}

[numthreads(GROUP_SIZE_2D, 1, 1)]
void VolumetricLighting(uint2 groupId       : SV_GroupID,
                        uint  groupThreadId : SV_GroupThreadID)
{
    // Note: any factor of 64 is a suitable wave size for our algorithm.
    uint waveIndex = WaveReadFirstLane(groupThreadId / 64);
    uint laneIndex = groupThreadId % 64;
    uint quadIndex = laneIndex / 4;

    // Arrange threads in the Morton order to optimally match the memory layout of GCN tiles.
    uint  mortonCode = groupThreadId;
    uint2 localCoord = DecodeMorton2D(mortonCode);
    uint2 groupCoord = groupId * GROUP_SIZE_1D;
    uint2 voxelCoord = groupCoord + localCoord;
    uint2 tileCoord  = voxelCoord * VBUFFER_TILE_SIZE / TILE_SIZE_CLUSTERED; // TODO: scalarize

    [branch] if (voxelCoord.x >= (uint)_VBufferResolutionAndScale.x ||
                 voxelCoord.y >= (uint)_VBufferResolutionAndScale.y)
    {
        return;
    }

    // TODO: use a low-discrepancy point set.
    float2 sampleCoord = voxelCoord + 0.5;

    // Compute the unnormalized ray direction s.t. its ViewSpaceZ = 1.
    float3 dir = -mul(float3(sampleCoord, 1), (float3x3)_VBufferCoordToViewDirWS);

    Ray cameraRay;
    cameraRay.originWS    = GetCurrentViewPosition();
    cameraRay.ratioLenToZ = sqrt(dot(dir, dir));
    cameraRay.ratioZtoLen = rsqrt(dot(dir, dir));
    cameraRay.directionWS = dir * cameraRay.ratioZtoLen;

    FillVolumetricLightingBuffer(cameraRay, voxelCoord, tileCoord);
}
