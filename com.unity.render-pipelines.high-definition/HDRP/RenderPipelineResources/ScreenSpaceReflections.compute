//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel ScreenSpaceReflectionsTracing      SSR_TRACE
#pragma kernel ScreenSpaceReflectionsReprojection SSR_REPROJECT

// Tweak parameters.
#define SSR_TRACE_EPS            0.00024414 // 2^-12, should be good up to 4K
#define SSR_TRACE_BEHIND_OBJECTS
#define SSR_TRACE_TOWARDS_EYE

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "CoreRP/ShaderLibrary/Common.hlsl"
#include "HDRP/ShaderVariables.hlsl"

#ifdef DEBUG_DISPLAY
    #include "CoreRP/ShaderLibrary/Debug.hlsl"
    #include "HDRP/Debug/DebugDisplay.hlsl"
#endif

#include "HDRP\Material\NormalBuffer.hlsl"

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

// TODO: remove me, I am just a temporary debug texture. :-)
RW_TEXTURE2D(float4, _SsrDebugTexture);

#ifdef SSR_TRACE
    // TEXTURE2D(        _NormalBufferTexture0); // Declared in NormalBuffer.hlsl.
    // TEXTURE2D(        _DepthPyramidTexture);  // Declared in ShaderVariablesScreenSpaceLighting.hlsl
    RW_TEXTURE2D(uint,   _SsrHitPointTexture);
#else // SSR_REPROJECT
    // TEXTURE2D(        _ColorPyramidTexture);  // Declared in ShaderVariablesScreenSpaceLighting.hlsl
       TEXTURE2D(        _VelocityTexture);
       TEXTURE2D(        _SsrHitPointTexture);
    RW_TEXTURE2D(float4, _SsrLightingTexture);
#endif

CBUFFER_START(UnityScreenSpaceReflections)
    int   _SsrIterLimit;
    float _SsrThicknessScale;
    float _SsrThicknessBias;
    float _SsrMaxRoughness;
    int   _SsrDepthPyramidMaxMip;
CBUFFER_END

//--------------------------------------------------------------------------------------------------
// Implementation
//--------------------------------------------------------------------------------------------------

#ifdef SSR_TRACE

[numthreads(8, 8, 1)]
void ScreenSpaceReflectionsTracing(uint2 positionSS : SV_DispatchThreadID)
{
    float2 positionNDC = positionSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw); // Should we precompute the half-texel bias? We seem to use it a lot.
    float  deviceDepth = LOAD_TEXTURE2D(_DepthPyramidTexture, positionSS).r;
    float3 positionWS  = ComputeWorldSpacePosition(positionNDC, deviceDepth, UNITY_MATRIX_I_VP); // Jittered
    float3 V           = GetWorldSpaceNormalizeViewDir(positionWS);

    // TODO: mark stencil during the G-Buffer pass with pixels which should receive SSR .
    // Reading the stencil is faster than reading the depth and the G-Buffer.
    bool killRay = deviceDepth == UNITY_RAW_FAR_CLIP_VALUE;

    // Load normal and roughness.
    NormalData normalData;
    DecodeFromNormalBuffer(positionSS, normalData);
    float3 N         = normalData.normalWS;
    float  roughness = normalData.perceptualRoughness;

    // Ref. #1: Michal Drobot - Quadtree Displacement Mapping with Height Blending.
    // Ref. #2: Yasin Uludag  - Hi-Z Screen-Space Cone-Traced Reflections.
    // Ref. #3: Jean-Philippe Grenier - Notes On Screen Space HIZ Tracing.
    // Warning: virtually all of the code below assumes reverse Z.

    // We start tracing from the center of the current pixel, and do so up to the far plane.
    float3 rayOrigin = float3(positionSS + 0.5, deviceDepth);

    // TODO: this does not match GGX.
    float3 R = reflect(-V, N);

    float3 reflPosWS  = positionWS + R;
    float3 reflPosNDC = ComputeNormalizedDeviceCoordinatesWithZ(reflPosWS, UNITY_MATRIX_VP); // Jittered
    float3 reflPosSS  = float3(reflPosNDC.xy * _ScreenSize.xy, reflPosNDC.z);
    float3 rayDir     = reflPosSS - rayOrigin;
    float3 rcpRayDir  = rcp(rayDir);
    int2   rayStep    = int2(rcpRayDir.x >= 0 ? 1 : 0,
                             rcpRayDir.y >= 0 ? 1 : 0);
    float3 raySign  = float3(rcpRayDir.x >= 0 ? 1 : -1,
                             rcpRayDir.y >= 0 ? 1 : -1,
                             rcpRayDir.z >= 0 ? 1 : -1);
    bool   rayTowardsEye  =  rcpRayDir.z >= 0;

    // Note that we don't need to store or read the roughness value
    // if we mark stencil during the G-Buffer pass with pixels which should receive SSR,
    // and sample the color pyramid during the lighting pass.
    killRay = killRay || (dot(N, V) <= 0);
    killRay = killRay || (roughness > _SsrMaxRoughness);
#ifndef SSR_TRACE_TOWARDS_EYE
    killRay = killRay || rayTowardsEye;
#endif

    if (killRay)
    {
        _SsrDebugTexture[positionSS]    = -1;
        _SsrHitPointTexture[positionSS] = asuint(-1);
        return;
    }

    // Extend and clip the end point to the frustum.
    float tMax;
    {
        // Shrink the frustum by half a texel for efficiency reasons.
        const float halfTexel = 0.5;

        float3 bounds;
        bounds.x = (rcpRayDir.x >= 0) ? _ScreenSize.x - halfTexel : halfTexel;
        bounds.y = (rcpRayDir.y >= 0) ? _ScreenSize.y - halfTexel : halfTexel;
        // Since we do not want to intersect the skybox, it is more efficient to not trace too far.
        bounds.z = (rcpRayDir.z >= 0) ? 1 : 0.00000012;

        float3 dist = bounds * rcpRayDir - (rayOrigin * rcpRayDir);
        tMax = Min3(dist.x, dist.y, dist.z);
    }

    // Start ray marching from the next texel to avoid self-intersections.
    float t;
    {
        // 'rayOrigin' is the exact texel center.
        float2 dist = abs(0.5 * rcpRayDir.xy);
        t = min(dist.x, dist.y);
    }

    float3 rayPos;

    int  mipLevel  = 0;
    int  iterCount = 0;
    bool hit       = false;
    bool miss      = false;
    bool belowMip0 = false; // This value is set prior to entering the cell

    while (!(hit || miss) && (t <= tMax) && (iterCount < _SsrIterLimit))
    {
        rayPos = rayOrigin + t * rayDir;

        // Ray position often ends up on the edge. To determine (and look up) the right cell,
        // we need to bias the position by a small epsilon in the direction of the ray.
        float2 sgnEdgeDist = round(rayPos.xy) - rayPos.xy;
        float2 satEdgeDist = clamp(raySign.xy * sgnEdgeDist + SSR_TRACE_EPS, 0, SSR_TRACE_EPS);
        rayPos.xy += raySign.xy * satEdgeDist;

        int2 mipCoord = (int2)rayPos.xy >> mipLevel;

        // Bounds define 4 faces of a cube:
        // 2 walls in front of the ray, and a floor and a base below it.
        float4 bounds;

        bounds.xy = (mipCoord + rayStep) << mipLevel;
        bounds.z  = LOAD_TEXTURE2D_LOD(_DepthPyramidTexture, mipCoord, mipLevel).r;
        rayPos.z  = bounds.z;
        // We define the depth of the base as the depth value as:
        // b = DeviceDepth((1 + thickness) * LinearDepth(d))
        // b = ((f - n) * d + n * (1 - (1 + thickness))) / ((f - n) * (1 + thickness))
        // b = ((f - n) * d - n * thickness) / ((f - n) * (1 + thickness))
        // b = d / (1 + thickness) - n / (f - n) * (thickness / (1 + thickness))
        // b = d * k_s + k_b
        bounds.w = bounds.z * _SsrThicknessScale + _SsrThicknessBias;

        float4 dist      = bounds * rcpRayDir.xyzz - (rayOrigin.xyzz * rcpRayDir.xyzz);
        float  distWall  = min(dist.x, dist.y);
        float  distFloor = dist.z;
        float  distBase  = dist.w;

        // Note: 'rayPos' given by 't' can correspond to one of several depth values:
        // - above or exactly on the floor
        // - inside the floor (between the floor and the base)
        // - below the base
        bool belowFloor  = (raySign.z * (t - distFloor)) <  0;
        bool aboveBase   = (raySign.z * (t - distBase )) >= 0;
        bool insideFloor = belowFloor && aboveBase;
        bool hitFloor    = (t <= distFloor) && (distFloor <= distWall);

        // Game rules:
        // * if the closest intersection is with the wall of the cell, switch to the coarser MIP, and advance the ray.
        // * if the closest intersection is with the heightmap below,  switch to the finer   MIP, and advance the ray.
        // * if the closest intersection is with the heightmap above,  switch to the finer   MIP, and do NOT advance the ray.
        // Victory conditions:
        // * See below. Do NOT reorder the statements!

        miss      = belowMip0 && insideFloor;
        hit       = (mipLevel == 0) && (hitFloor || insideFloor);
        belowMip0 = (mipLevel == 0) && belowFloor;

    #ifndef SSR_TRACE_BEHIND_OBJECTS
        miss = belowMip0;
    #endif

        // 'distFloor' can be smaller than the current distance 't'.
        // We can also safely ignore 'distBase'.
        // If we hit the floor, it's always safe to jump there.
        // If we are at (mipLevel != 0) and we are below the floor, we should not move.
        t = hitFloor ? distFloor : (((mipLevel != 0) && belowFloor) ? t : distWall);

        // Warning: both rays towards the eye, and tracing behind objects has linear
        // rather than logarithmic complexity! This is due to the fact that we only store
        // the maximum value of depth, and not the min-max.
        mipLevel += (hitFloor || belowFloor || rayTowardsEye) ? -1 : 1;
        mipLevel  = clamp(mipLevel, 0, _SsrDepthPyramidMaxMip);

        // mipLevel = 0;

        iterCount++;
    }

    // Treat intersections with the sky as misses.
    miss = miss || (rayPos.z == 0);
    hit  = hit && !miss;

    uint2 hitPositionSS = asuint(-1);

    if (hit)
    {
        // Note that we are using 'rayPos' from the penultimate iteration, rather than
        // recompute it using the last value of 't', which would result in an overshoot.
        // It also needs to be precisely at the center of the pixel to avoid artifacts.
        hitPositionSS = (uint2)rayPos.xy;
    }

    _SsrDebugTexture[positionSS]    = float4(hit ? hitPositionSS : -1, iterCount, hit);
    _SsrHitPointTexture[positionSS] = (hitPositionSS.y << 16) | (hitPositionSS.x);
}

#else // SSR_REPROJECT

[numthreads(8, 8, 1)]
void ScreenSpaceReflectionsReprojection(uint2 positionSS : SV_DispatchThreadID)
{
    uint   hitInfo        = asuint(LOAD_TEXTURE2D(_SsrHitPointTexture, positionSS).r);
    uint2  hitPositionSS  = uint2(hitInfo & 0xFFFF, hitInfo >> 16);
    float2 hitPositionNDC = hitPositionSS * _ScreenSize.zw + (0.5 * _ScreenSize.zw); // Should we precompute the half-texel bias? We seem to use it a lot.


    if (hitInfo == asuint(-1))
    {
        _SsrLightingTexture[positionSS] = 0;
        return;
    }

    // float  opacity = CalculateFullWeight(hitPositionNDC, _SSReflectionInvScreenWeightDistance, hitWeight, hitSuccessful);
    // float mipLevel = PlanarPerceptualRoughnessToMipmapLevel(perceptualRoughness, _ColorPyramidScale.z);

    float  mipLevel    = 0;
    float2 velocityNDC = LOAD_TEXTURE2D(_VelocityTexture, hitPositionSS).xy;
    float3 color       = SAMPLE_TEXTURE2D_LOD(_ColorPyramidTexture, s_trilinear_clamp_sampler, hitPositionNDC - velocityNDC, mipLevel).rgb;
    float  opacity     = 1;

    _SsrLightingTexture[positionSS] = float4(color, opacity);
}

#endif
