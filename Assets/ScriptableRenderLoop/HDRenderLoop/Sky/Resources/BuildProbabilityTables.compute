// TODO: add description

#include "Common.hlsl"

/* --- Input --- */

#define textureSize 128                  // TODO: make this dynamic

int cubeFaceId;                          // Cubemap face index

TEXTURE2D(EnvMap)                        // Cubemap face

/* --- Output --- */

RWTexture2D<float> marginalRowDensities; // One column per face
RWTexture2D<float> conditionalDensities; // Cubemap face

/* --- Shared --- */

groupshared float rowIntegralValues[textureSize];

/* --- Implementation --- */

#pragma kernel BuildProabilityTables

[numthreads(1, textureSize, 1)]
void BuildProabilityTables(uint3 groupId          : SV_GroupID,
                           uint3 groupThreadId    : SV_GroupThreadID,
                           uint3 dispatchThreadId : SV_DispatchThreadID,
                           uint  groupIndex       : SV_GroupIndex)
{
    // A single thread group processes a row of 'textureSize' texels.
    int j = groupThreadId.y;

    // TODO: reduce storage requirements.
    float temp[textureSize];

    // Compute the integral of the step function.
    float rowIntegralValue = 0.0;

    // Suppress the D3D compiler warning.
    int i;

    // TODO: run in parallel.
    for (i = 0; i < textureSize; i++)
    {
        temp[i] = rowIntegralValue;

        // We use MIP level 1 to account for interpolation during light sampling.
        // Ref: PBRT v3, page 847.
        float3 color     = LOAD_TEXTURE2D_LOD(EnvMap, int2(i, j), 1).rgb;
        float  intensity = color.r + color.g + color.b;

        rowIntegralValue += intensity / textureSize;
    }

    // Prevent NaNs arising from the division of 0 by 0.
    rowIntegralValue = max(rowIntegralValue, FLT_MIN);

    // Compute the CDF. Note: the value at (i = textureSize) is implicitly 1.
    // TODO: run in parallel.
    for (i = 0; i < textureSize; i++)
    {
        conditionalDensities[int2(i, j)] = temp[i] / rowIntegralValue;
    }

    // Store the value of the integral.
    rowIntegralValues[j] = rowIntegralValue;
    GroupMemoryBarrierWithGroupSync();

    if (groupIndex == 0)
    {
        // Compute the integral of the step function.
        float imgIntegralValue = 0.0;

        // TODO: run in parallel.
        for (j = 0; j < textureSize; j++)
        {
            temp[j] = imgIntegralValue;

            imgIntegralValue += rowIntegralValues[j] / textureSize;
        }

        // Compute marginal densities (normalize).
        // TODO: run in parallel.
        for (j = 0; j < textureSize; j++)
        {
            marginalRowDensities[int2(cubeFaceId, j)] = temp[j] / imgIntegralValue;
        }
    }
}
