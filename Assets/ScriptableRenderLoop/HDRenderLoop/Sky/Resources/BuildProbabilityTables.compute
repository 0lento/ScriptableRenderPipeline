// TODO: add description

#include "Common.hlsl"

/* --- Input --- */

#define textureSize 128                  // TODO: make this dynamic

uint cubeFaceId;                         // Cubemap face index

TEXTURE2D(EnvMap)                        // Cubemap face
SAMPLER2D(sampler_EnvMap)

/* --- Output --- */

RWTexture2D<float> marginalRowDensities; // One column per face
RWTexture2D<float> conditionalDensities; // Cubemap face

/* --- Shared --- */

groupshared float rowIntegralValues[textureSize];

/* --- Implementation --- */

#pragma kernel BuildProabilityTables

[numthreads(1, textureSize, 1)]
void BuildProabilityTables(uint3 groupId          : SV_GroupID,
                           uint3 groupThreadId    : SV_GroupThreadID,
                           uint3 dispatchThreadId : SV_DispatchThreadID,
                           uint  groupIndex       : SV_GroupIndex)
{
    // A single thread group processes a row of 'textureSize' texels.
    const uint  j = groupThreadId.y;
    const float y = j / textureSize + (0.5 / textureSize);

    float temp[textureSize];

    // Compute the integral of the step function.
    float rowIntegralValue = 0.0;

    // TODO: run in parallel.
    for (uint i = 0; i < textureSize; i++)
    {
        temp[i] = rowIntegralValue;

        float x = i / textureSize + (0.5 / textureSize);

        // We use MIP level 1 to account for interpolation during light sampling.
        // Ref: PBRT v3, page 847.
        float3 color     = SAMPLE_TEXTURE2D_LOD(EnvMap, sampler_EnvMap, float2(x, y), 1).rgb;
        float  intensity = color.r + color.g + color.b;

        rowIntegralValue += intensity / textureSize;
    }

    // Prevent NaNs arising from the division of 0 by 0.
    rowIntegralValue = max(rowIntegralValue, FLT_MIN);

    // Compute the CDF. Note: the value at (i = textureSize) is implicitly 1.
    // TODO: run in parallel.
    for (uint i = 0; i < textureSize; i++)
    {
        conditionalDensities[uint2(i, j)] = temp[i] / rowIntegralValue;
    }

    // Store the value of the integral.
    rowIntegralValues[j] = rowIntegralValue;
    GroupMemoryBarrierWithGroupSync();

    if (groupIndex == 0)
    {
        // Compute the integral of the step function.
        float imgIntegralValue = 0.0;

        // TODO: run in parallel.
        for (uint i = 0; i < textureSize; i++)
        {
            temp[i] = imgIntegralValue;

            imgIntegralValue += rowIntegralValues[i] / textureSize;
        }

        // Compute marginal densities (normalize).
        // TODO: run in parallel.
        for (uint i = 0; i < textureSize; i++)
        {
            marginalRowDensities[uint2(i, cubeFaceId)] = temp[i] / imgIntegralValue;
        }
    }
}
