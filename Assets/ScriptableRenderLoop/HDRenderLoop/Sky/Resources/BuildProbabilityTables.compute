// TODO: add description

#include "Common.hlsl"

/* --- Input --- */

#define textureSize 128                  // The size of the MIP level 1 of the input texture

int cubeFaceId;                          // Cubemap face index

TEXTURE2D(envMap)                        // Cubemap face (s.t. MIP 1: [textureSize x textureSize])

/* --- Output --- */

RWTexture2D<float> marginalRowDensities; // One row per face: [textureSize x 8]
RWTexture2D<float> conditionalDensities; // Cubemap face: [textureSize x textureSize]

/* --- Shared --- */

groupshared float rowIntegralValues[textureSize];

/* --- Implementation --- */

#pragma kernel BuildProabilityTables

[numthreads(1, textureSize, 1)]
void BuildProabilityTables(uint3 groupId          : SV_GroupID,
                           uint3 groupThreadId    : SV_GroupThreadID,
                           uint3 dispatchThreadId : SV_DispatchThreadID,
                           uint  groupIndex       : SV_GroupIndex)
{
    // A single thread group processes a row of 'textureSize' texels.
    const int j = groupThreadId.y;

    // TODO: reduce storage requirements.
    /* HUGE */ float temp[textureSize];

    // Compute the integral of the step function.
    float rowIntegralValue = 0.0;

    // Suppress the D3D compiler warning.
    int i;

    // TODO: run in parallel.
    for (i = 0; i < textureSize; i++)
    {
        temp[i] = rowIntegralValue;

        // We use MIP level 1 to account for interpolation during light sampling.
        // Ref: PBRT v3, page 847.
        float3 color     = LOAD_TEXTURE2D_LOD(envMap, int2(i, j), 1).rgb;
        float  intensity = color.r + color.g + color.b;

        rowIntegralValue += intensity / textureSize;
    }

    // Prevent NaNs arising from the division of 0 by 0.
    rowIntegralValue = max(rowIntegralValue, FLT_MIN);

    // Compute the CDF. Note: the value at (i = textureSize) is implicitly 1.
    // TODO: run in parallel.
    for (i = 0; i < textureSize; i++)
    {
        conditionalDensities[int2(i, j)] = temp[i] / rowIntegralValue;
    }

    // Store the value of the integral.
    rowIntegralValues[j] = rowIntegralValue;
    GroupMemoryBarrierWithGroupSync();

    if (groupIndex == 0)
    {
        // Compute the integral of the step function.
        float imgIntegralValue = 0.0;

        // TODO: run in parallel.
        for (i = 0; i < textureSize; i++)
        {
            temp[i] = imgIntegralValue;

            imgIntegralValue += rowIntegralValues[i] / textureSize;
        }

        // Compute the CDF. Note: the value at (i = textureSize) is implicitly 1.
        // TODO: run in parallel.
        for (i = 0; i < textureSize; i++)
        {
            marginalRowDensities[int2(i, cubeFaceId)] = temp[i] / imgIntegralValue;
        }

        // Store the value of the integral of the entire image.
        // TODO: find a better place for this.
        marginalRowDensities[int2(0, 6)] = imgIntegralValue;
    }
}
