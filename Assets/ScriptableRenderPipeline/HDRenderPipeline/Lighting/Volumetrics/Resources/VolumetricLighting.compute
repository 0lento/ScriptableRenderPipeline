//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

#pragma kernel VolumetricLightingAllLights VolumetricLighting=VolumetricLightingAllLights LIGHTLOOP_SINGLE_PASS
#pragma kernel VolumetricLightingClustered VolumetricLighting=VolumetricLightingClustered LIGHTLOOP_TILE_PASS   USE_CLUSTERED_LIGHTLIST

#pragma enable_d3d11_debug_symbols

#include "../../../ShaderPass/ShaderPass.cs.hlsl"
#define SHADERPASS    SHADERPASS_VOLUMETRIC_LIGHTING
#define GROUP_SIZE_1D 16
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "../../../../Core/ShaderLibrary/Common.hlsl"
#include "../../../../Core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "../../../../Core/ShaderLibrary/VolumeRendering.hlsl"

#include "../HomogeneousFog.cs.hlsl"
#define UNITY_MATERIAL_LIT // Need to be defined before including Material.hlsl
#include "../../../ShaderVariables.hlsl"
#include "../../../Lighting/Lighting.hlsl" // This includes Material.hlsl

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

TEXTURE2D(_DepthTexture);               // Z-buffer
RW_TEXTURE2D(float4, _CameraColorTexture); // Updated texture

//--------------------------------------------------------------------------------------------------
// Implementation
//--------------------------------------------------------------------------------------------------

struct Ray
{
    float3 originWS;
    float3 directionWS; // Normalized
    float  maxLength;   // In meters
};

// Computes the in-scattered radiance along the ray.
float3 PerformIntegration(PositionInputs posInput, Ray ray, uint numSteps)
{
    float3 extinction = _GlobalFog_Extinction;
    float  asymmetry  = _GlobalFog_Asymmetry;
    float3 scattering = _GlobalFog_Scattering;

    LightLoopContext context;
    // ZERO_INITIALIZE(LightLoopContext, context);
    context.shadowContext = InitShadowContext();

    float maxDepthVS = posInput.depthVS;

    // Note: we are already using 'unPositionSS' for randomization of LODDitheringTransition().
    float zeta = GenerateHashedRandomFloat(posInput.unPositionSS.yx);

    float du = rcp(numSteps);
    float u0 = 0.25 * du + 0.5 * du * zeta;
    float dt = du * ray.maxLength;

    float3 radiance = 0;

    for (uint i = 0; i < numSteps; i++)
    {
        float u = u0 + i * du;          // [0, 1]
        float t = u * ray.maxLength;    // [0, ray.maxLength]

        float3 samplePositionWS = ray.originWS + t * ray.directionWS;

        // if (featureFlags & LIGHTFEATUREFLAGS_PUNCTUAL)
        {
            uint punctualLightCount;

        #ifdef LIGHTLOOP_TILE_PASS
            uint punctualLightStart;

            posInput.depthVS = u * maxDepthVS;
            GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, punctualLightStart, punctualLightCount);
        #else
            punctualLightCount = _PunctualLightCount;
        #endif

            for (uint j = 0; j < punctualLightCount; ++j)
            {
            #ifdef LIGHTLOOP_TILE_PASS
                uint punctualLightIndex = FetchIndex(punctualLightStart, j);
            #else
                uint punctualLightIndex = j;
            #endif

                // Fetch the light.
                LightData lightData = _LightDatas[punctualLightIndex];

                float3 sampleToLight = lightData.positionWS - samplePositionWS;

                // Compute the distance to the light, and the associated transmittance values.
                float  distSq  = dot(sampleToLight, sampleToLight);
                float  dist    = sqrt(distSq);
                float3 L       = sampleToLight * rsqrt(distSq);
                float  LdotD   = dot(L, ray.directionWS);
                float  phase   = HenyeyGreensteinPhaseFunction(asymmetry, LdotD);
                float3 lightT  = Transmittance(OpticalDepthHomogeneous(extinction, dist));
                float3 sampleT = Transmittance(OpticalDepthHomogeneous(extinction, t));

                // Note: lightData.invSqrAttenuationRadius is 0 when applyRangeAttenuation is false
                float attenuation = (lightData.lightType != GPULIGHTTYPE_PROJECTOR_BOX) ? GetDistanceAttenuation(distSq, lightData.invSqrAttenuationRadius) : 1;
                // Reminder: lights are oriented backward (-Z)
                attenuation *= GetAngleAttenuation(L, -lightData.forward, lightData.angleScale, lightData.angleOffset);

                float shadow = 1;

                [branch] if (lightData.shadowIndex >= 0)
                {
                    // TODO: make projector lights cast shadows.
                    float3 offset = 0; // GetShadowPosOffset(nDotL, normal);

                    shadow = GetPunctualShadowAttenuation(context.shadowContext, samplePositionWS + offset, 0, lightData.shadowIndex, float4(L, dist), posInput.unPositionSS);
                    shadow = lerp(1.0, shadow, lightData.shadowDimmer);
                }

                // Compute the amount of in-scattered radiance.
                radiance += (dt * scattering * phase * attenuation * shadow) * (lightT * sampleT) * lightData.color;
            }
        }
    }

    return radiance;
}

[numthreads(GROUP_SIZE_2D, 1, 1)]
void VolumetricLighting(uint2 groupId       : SV_GroupID,
                        uint  groupThreadId : SV_GroupThreadID)
{
    // Note: any factor of 64 is a suitable wave size for our algorithm.
    uint waveIndex = groupThreadId / 64;
    uint laneIndex = groupThreadId % 64;
    uint quadIndex = laneIndex / 4;

    // Arrange threads in the Morton order to optimally match the memory layout of GCN tiles.
    uint  mortonCode = groupThreadId;
    uint2 localCoord = DecodeMorton2D(mortonCode);
    uint2 tileAnchor = groupId * GROUP_SIZE_1D;
    uint2 pixelCoord = tileAnchor + localCoord;
    uint2 tileCoord  = pixelCoord / GetTileSize();

    if (pixelCoord.x >= (uint)_ScreenSize.x || pixelCoord.y >= (uint)_ScreenSize.y) { return; }

#ifdef UNITY_REVERSED_Z
    float z = max(LOAD_TEXTURE2D(_DepthTexture, pixelCoord).r, 0 + 0.001);
#else
    float z = min(LOAD_TEXTURE2D(_DepthTexture, pixelCoord).r, 1 - 0.001);
#endif

    PositionInputs posInput = GetPositionInput(pixelCoord, _ScreenSize.zw, tileCoord);
    UpdatePositionInput(z, _InvViewProjMatrix, _ViewProjMatrix, posInput);

    Ray cameraRay;

    // Note: the camera ray does not start on the the near (camera sensor) plane.
    // While this is not correct (strictly speaking), the introduced error is small.
    cameraRay.originWS     = GetCurrentViewPosition();
    cameraRay.directionWS  = posInput.positionWS - cameraRay.originWS;
    cameraRay.maxLength    =  sqrt(dot(cameraRay.directionWS, cameraRay.directionWS));
    cameraRay.directionWS *= rsqrt(dot(cameraRay.directionWS, cameraRay.directionWS)); //Normalize

    float3 rayT = Transmittance(OpticalDepthHomogeneous(_GlobalFog_Extinction, cameraRay.maxLength));

    const int numSamples = 64;
    float3 inL = PerformIntegration(posInput, cameraRay, numSamples);

    // In-place UAV updates do not work on Intel GPUs.
    _CameraColorTexture[pixelCoord] = float4(rayT * _CameraColorTexture[pixelCoord].rgb + inL, _CameraColorTexture[pixelCoord].a);
}
