//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

#pragma kernel VolumetricLightingAllLights VolumetricLighting=VolumetricLightingAllLights LIGHTLOOP_SINGLE_PASS
#pragma kernel VolumetricLightingClustered VolumetricLighting=VolumetricLightingClustered LIGHTLOOP_TILE_PASS   USE_CLUSTERED_LIGHTLIST

#pragma enable_d3d11_debug_symbols

#define GROUP_SIZE_1D 16
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "../../../../Core/ShaderLibrary/Common.hlsl"
#include "../../../../Core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "../../../../Core/ShaderLibrary/VolumeRendering.hlsl"

#include "../HomogeneousFog.cs.hlsl"
#define UNITY_MATERIAL_LIT // Need to be defined before including Material.hlsl
#include "../../../ShaderVariables.hlsl"
#include "../../../Lighting/Lighting.hlsl" // This includes Material.hlsl

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

TEXTURE2D(_DepthTexture);               // Z-buffer
RW_TEXTURE2D(float4, _LightingTexture); // Updated texture

// Unity does not support structures inside constant buffers,
// so we are forced to use a structured buffer instead.
StructuredBuffer<VolumeProperties> _UnboundedVolume;

//--------------------------------------------------------------------------------------------------
// Implementation
//--------------------------------------------------------------------------------------------------

struct Ray
{
    float3 originWS;
    float3 directionWS; // Not normalized
    float  maxLength;
};

// Integrates the volume along the ray to
float3 IntegrateVolume() {return 0;}

[numthreads(GROUP_SIZE_2D, 1, 1)]
void VolumetricLighting(uint2 groupId       : SV_GroupID,
                        uint  groupThreadId : SV_GroupThreadID)
{
    // Note: any factor of 64 is a suitable wave size for our algorithm.
    uint waveIndex = groupThreadId / 64;
    uint laneIndex = groupThreadId % 64;
    uint quadIndex = laneIndex / 4;

    // Arrange threads in the Morton order to optimally match the memory layout of GCN tiles.
    uint  mortonCode = groupThreadId;
    uint2 localCoord = DecodeMorton2D(mortonCode);
    uint2 tileAnchor = groupId * GROUP_SIZE_1D;
    uint2 pixelCoord = tileAnchor + localCoord;

    PositionInputs posInput = GetPositionInput(pixelCoord, _ScreenSize.zw);
    UpdatePositionInput(LOAD_TEXTURE2D(_DepthTexture, pixelCoord).r, _InvViewProjMatrix, _ViewProjMatrix, posInput);

    Ray ray;

    // Note: the camera ray does not start on the the near (image) plane.
    // While this is not correct (strictly speaking), the introduced error is small.
    ray.originWS    = GetCurrentViewPosition();
    ray.directionWS = posInput.positionWS - ray.originWS;
    ray.maxLength   = length(ray.directionWS);

    float3 transmittance = Transmittance(OpticalDepthHomogeneous(_UnboundedVolume[0].extinction, ray.maxLength));

    // In-place UAV updates do not work on Intel GPUs.
    _LightingTexture[pixelCoord] = float4(transmittance * _LightingTexture[pixelCoord].rgb, _LightingTexture[pixelCoord].a);
}
